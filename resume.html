<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Resume</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style type="text/css">

			canvas{
				display: block;
				margin: 0 auto;
			}

			body {
					font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
					font-weight: 300;
					width: 800px;
					margin: auto;
					background: #FFFFFF;
					padding: 10px 10px 10px 10px;
			}

			h1 {
					font-size: 55px;
					color: #1e6db5;
					margin-bottom:15px;
					text-align: left;
			}

			h2 {
					/* This is called "sectioncolor" in the ConTeXt stylesheet. */
					color: #45a4e0;
			}

			h2:before {
					content: "";
					display: inline-block;
					margin-right:1%;
					width: 16%;
					height: 10px;
					/* This is called "rulecolor" in the ConTeXt stylesheet. */
					background-color: #b5dbf1;
			}

			dt {
					float: left;
					clear: left;
					width: 17%;
			}

			dd {
					margin-left: 17%;
			}
			p {
					margin-top:0;
					margin-bottom:7px;
			}

			blockquote {
					text-align: center
			}

			a {
					text-decoration: none;
					color: #1e6db5;
			}
			a:hover, a:active {
					background-color: #1e6db5;
					color: #FFFFFF;
					text-decoration: none;
					text-shadow: 1px 1px 1px #333;
			}

			hr {
					color: #A6A6A6;
			}

			table {
					width: 100%;
			}
			</style>
	</head>
	<body>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r80/three.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/SimplexNoise.js"></script>
		<script src="js/GPUComputationRenderer.js"></script>

		<!-- This is the 'compute shader' for the water heightmap: -->
		<script id="heightmapFragmentShader" type="x-shader/x-fragment">

			#include <common>

			uniform vec2 mousePos;
			uniform float mouseSize;
			uniform float viscosityConstant;

			#define deltaTime ( 1.0 / 100.0 )
			#define GRAVITY_CONSTANT ( resolution.x * deltaTime * 3.0 )

			void main()	{

				vec2 cellSize = 1.0 / resolution.xy;

				vec2 uv = gl_FragCoord.xy * cellSize;

				// heightmapValue.x == height
				// heightmapValue.y == velocity
				// heightmapValue.z, heightmapValue.w not used
				vec4 heightmapValue = texture2D( heightmap, uv );

				// Get neighbours
				vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
				vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
				vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
				vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );

				float sump = north.x + south.x + east.x + west.x - 4.0 * heightmapValue.x;

				float accel = sump * GRAVITY_CONSTANT;

				// Dynamics
				heightmapValue.y += accel;
				heightmapValue.x += heightmapValue.y * deltaTime;

				// Viscosity
				heightmapValue.x += sump * viscosityConstant;

				// Mouse influence
				float mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );
				heightmapValue.x += cos( mousePhase ) + 1.0;

				gl_FragColor = heightmapValue;

			}

		</script>

		<!-- This is just a smoothing 'compute shader' for using manually: -->
		<script id="smoothFragmentShader" type="x-shader/x-fragment">

			uniform sampler2D texture;

			void main()	{

				vec2 cellSize = 1.0 / resolution.xy;

				vec2 uv = gl_FragCoord.xy * cellSize;

				// Computes the mean of texel and 4 neighbours
				vec4 textureValue = texture2D( texture, uv );
				textureValue += texture2D( texture, uv + vec2( 0.0, cellSize.y ) );
				textureValue += texture2D( texture, uv + vec2( 0.0, - cellSize.y ) );
				textureValue += texture2D( texture, uv + vec2( cellSize.x, 0.0 ) );
				textureValue += texture2D( texture, uv + vec2( - cellSize.x, 0.0 ) );

				textureValue /= 5.0;

				gl_FragColor = textureValue;

			}

		</script>

		<!-- This is the water visualization shader, copied from the MeshPhongMaterial and modified: -->
		<script id="waterVertexShader" type="x-shader/x-vertex">

			uniform sampler2D heightmap;

			#define PHONG

			varying vec3 vViewPosition;

			#ifndef FLAT_SHADED

				varying vec3 vNormal;

			#endif

			#include <common>
			#include <uv_pars_vertex>
			#include <uv2_pars_vertex>
			#include <displacementmap_pars_vertex>
			#include <envmap_pars_vertex>
			#include <color_pars_vertex>
			#include <morphtarget_pars_vertex>
			#include <skinning_pars_vertex>
			#include <shadowmap_pars_vertex>
			#include <logdepthbuf_pars_vertex>
			#include <clipping_planes_pars_vertex>

			void main() {

				vec2 cellSize = vec2( 2.0 / WIDTH, 2.0 / WIDTH );

				#include <uv_vertex>
				#include <uv2_vertex>
				#include <color_vertex>

				// # include <beginnormal_vertex>
				// Compute normal from heightmap
				vec3 objectNormal = vec3(
					( texture2D( heightmap, uv + vec2( - cellSize.x, 1 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
					( texture2D( heightmap, uv + vec2( 0.1, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
					1.0 );
				//<beginnormal_vertex>

				#include <morphnormal_vertex>
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#include <defaultnormal_vertex>

			#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

				vNormal = normalize( transformedNormal );

			#endif

				//# include <begin_vertex>
				float heightValue = texture2D( heightmap, uv ).x;
				vec3 transformed = vec3( position.x, position.y, heightValue );
				//<begin_vertex>

				#include <morphtarget_vertex>
				#include <skinning_vertex>
				#include <displacementmap_vertex>
				#include <project_vertex>
				#include <logdepthbuf_vertex>
				#include <clipping_planes_vertex>

				vViewPosition = mvPosition.xyz;

				#include <worldpos_vertex>
				#include <envmap_vertex>
				#include <shadowmap_vertex>

			}

		</script>

		<div id='resume'>
			<h1 id="pascal-lamouric">Pascal Lamouric</h1>
			<p>French engineer who wants to automate all the things, available for contracting work and/or full remote positions.</p>
			<p>⇢ <a href="mailto:hello@pascal.cc">hello@pascal.cc</a></p>
			<p>⇢ <a href="https://www.linkedin.com/in/pascal-lamouric/">LinkedIn</a> / <a href="https://github.com/pskl">GitHub</a></p>
			<h2 id="work-experience">Work Experience</h2>
			<p><strong>2016/2017/2018 - Backend engineer @ <a href="http://liqid.de">Liqid.de</a> (Germany, 2 years)</strong></p>
			<p>Helped the initial founding team build the backend from the ground up and refactored it through its numerous mutations. The application is 2 parts:</p>
			<ul>
			<li>a complex entirely automated banking compliant registration process interfaced with several third parties including DocuSign, PostIdent and Salesforce</li>
			<li>a wealth management portfolio monitoring system which extracts and formats information from an interface with DeutscheBank</li>
			</ul>
			<p>A very strong emphasis was laid on code coverage using RSpec (over 90%), reliability, modularity, maintainability, containerization (using Docker + Kubernetes) and open source contributions. Languages used: Ruby, JavaScript.</p>
			<p><strong>2015 - Full Stack developer @ <a href="http:://www.undeveloped.nl">Undeveloped.nl</a> (Netherlands, 2 months)</strong></p>
			<p>During a short voluntary summer job I worked on revamping the registration process and implemented a new payment processing provider using AngularJS in the frontend and Ruby on Rails in the backend.</p>
			<p><strong>2015 - Full Stack developer @ <a href="http:://www.achieved.co">Achieved.co</a> (Netherlands, 5 months)</strong></p>
			<p>I worked with the Achieved team for my entrepreneurship internship. For a new product concept they came up with I created a Ruby on Rails API and used the Ionic framework to make a cross-platform application. This project allowed me to have a bigger vision of product development as a whole and taught me how to quickly launch a <a href="https://www.techopedia.com/definition/27809/minimum-viable-product-mvp">MVP</a>.</p>
			<h2 id="academia">Academia</h2>
			<p><strong>2014-2015 - MSc Innovation &amp; Entrepreneurship @ <a href="https://www.esc-rennes.fr/index.php/en">ESC Rennes</a> (France)</strong></p>
			<p>Business administration, Entrepreneurship, Management</p>
			<p><strong>2010-2015 - Master of Computer Science @ <a href="https://www.insa-rennes.fr/en.html">INSA Rennes</a> (France)</strong></p>
			<p>Mathematics, Software engineering, Networks, Computing architecture</p>
			<h2 id="skills">Skills</h2>
			<p><strong>Web development</strong></p>
			<ul>
			<li> Ruby (3 years professional experience)</li>
			<li> JavaScript</li>
			<li> Python</li>
			<li> web development fundamentals: CSS, HTML, XML, JSON, YAML...</li>
			</ul>
			<h2 id="open-source">Open Source</h2>
			<ul>
			<li><a href="https://github.com/LIQIDTechnology/toku">Toku</a>: modular database anonymizer for Postgres databases written in Ruby.</li>
			</ul>
			<h2 id="miscellaneous">Miscellaneous</h2>
			<p><strong>Languages</strong></p>
			<ul>
			<li> English (bilingual)</li>
			<li> French (native)</li>
			<li> Spanish (working proficiency)</li>
			<li> German (beginner)</li>
			<li> Japanese (beginner)</li>
			</ul>
			<p><strong>Hobbies</strong></p>
			<ul>
			<li>Creative coding (hobby projects like <a href="https://github.com/pskl/glitch3d">Glitch3D</a>)</li>
			<li><a href="https://en.wikipedia.org/wiki/Digital_nomad">Digital nomadism</a></li>
			<li>Hackathons (<a href="https://github.com/pskl/vr-force-directed-graph">VR force directed graphs</a>)</li>
			</ul>
		</div>

		<div id='canvas-container'>
		</div>
		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var hash = document.location.hash.substr( 1 );
			if ( hash ) hash = parseInt( hash, 0 );

			// Texture width for simulation
			var WIDTH = 30;
			var NUM_TEXELS = WIDTH * WIDTH;

			// Water size in system units
			var BOUNDS = 250;
			var BOUNDS_HALF = BOUNDS * 0.5;

			var container, stats;
			var camera, scene, renderer, controls;
			var mouseMoved = false;
			var mouseCoords = new THREE.Vector2();
			var raycaster = new THREE.Raycaster();

			var waterMesh;
			var meshRay;
			var gpuCompute;
			var heightmapVariable;
			var waterUniforms;
			var smoothShader;

			var simplex = new SimplexNoise();

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			function change(n) {
				location.hash = n;
				location.reload();
				return false;
			}


			var options = '';
			for ( var i = 4; i < 10; i++ ) {
				var j = Math.pow( 2, i );
				options += '<a href="#" onclick="return change(' + j + ')">' + j + 'x' + j + '</a> ';
			}
			init();
			animate();

			function init() {

				container = document.getElementById("canvas-container");
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.set( 0, 50, 350 );

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer({ alpha: true });
				// renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize(400, 400);
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );
				window.addEventListener( 'resize', onWindowResize, false );

				initWater();

				heightmapVariable.material.uniforms.mouseSize.value = 10;
				heightmapVariable.material.uniforms.viscosityConstant.value = 0.02;

			}


			function initWater() {

				var materialColor = 0x11111;

				var geometry = new THREE.PlaneBufferGeometry( BOUNDS, BOUNDS, WIDTH - 1, WIDTH -1 );

				// material: make a ShaderMaterial clone of MeshPhongMaterial, with customized vertex shader
				var material = new THREE.ShaderMaterial( {
					uniforms: THREE.UniformsUtils.merge( [
						THREE.ShaderLib[ 'phong' ].uniforms,
						{
							heightmap: { value: null }
						}
					] ),
					vertexShader: document.getElementById( 'waterVertexShader' ).textContent,
					fragmentShader: THREE.ShaderChunk[ 'normal_frag' ]

				} );

				material.lights = true;

				// Material attributes from MeshPhongMaterial
				material.color = new THREE.Color( materialColor );
				material.specular = new THREE.Color( 0xB75CC7 );
				material.shininess = 30;

				// Sets the uniforms with the material values
				material.uniforms.diffuse.value = material.color;
				material.uniforms.specular.value = material.specular;
				material.uniforms.shininess.value = Math.max( material.shininess, 1e-4 );
				material.uniforms.opacity.value = material.opacity;

				// Defines
				material.defines.WIDTH = WIDTH.toFixed( 1 );
				material.defines.BOUNDS = BOUNDS.toFixed( 1 );

				waterUniforms = material.uniforms;

				waterMesh = new THREE.Mesh( geometry, material );
				// waterMesh.matrixAutoUpdate = false;
				waterMesh.material.wireframe = true;
				waterMesh.rotation.x =  - Math.PI / 2;
				waterMesh.updateMatrix();
				scene.add( waterMesh );

				// Mesh just for mouse raycasting
				var geometryRay = new THREE.PlaneBufferGeometry( BOUNDS, BOUNDS, 1, 1 );
				meshRay = new THREE.Mesh( geometryRay, new THREE.MeshBasicMaterial( { color: 0xFFFFFF, visible: false } ) );
				meshRay.rotation.x = - Math.PI / 2;
				meshRay.matrixAutoUpdate = false;
				meshRay.updateMatrix();
				scene.add( meshRay );

				// Creates the gpu computation class and sets it up

				gpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );

				var heightmap0 = gpuCompute.createTexture();

				fillTexture( heightmap0 );

				heightmapVariable = gpuCompute.addVariable( "heightmap", document.getElementById( 'heightmapFragmentShader' ).textContent, heightmap0 );

				gpuCompute.setVariableDependencies( heightmapVariable, [ heightmapVariable ] );

				heightmapVariable.material.uniforms.mousePos = { value: new THREE.Vector2( 10000, 10000 ) };
				heightmapVariable.material.uniforms.mouseSize = { value: 10.0 };
				heightmapVariable.material.uniforms.viscosityConstant = { value: 0.02 };
				heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed( 1 );

				var error = gpuCompute.init();
				if ( error !== null ) {
				    console.error( error );
				}

				// Create compute shader to smooth the water surface and velocity
				smoothShader = gpuCompute.createShaderMaterial( document.getElementById( 'smoothFragmentShader' ).textContent, { texture: { value: null } } );

			}

			function fillTexture( texture ) {

				var waterMaxHeight = 100;

				function noise( x, y, z ) {
					var multR = waterMaxHeight;
					var mult = 0.025;
					var r = 0;
					for ( var i = 0; i < 15; i++ ) {
						r += multR * simplex.noise( x * mult, y * mult );
						multR *= 0.53 + 0.025 * i;
						mult *= 1.25;
					}
					return r;
				}

				var pixels = texture.image.data;

				var p = 0;
				for ( var j = 0; j < WIDTH; j++ ) {
					for ( var i = 0; i < WIDTH; i++ ) {

						var x = i * 128 / WIDTH;
						var y = j * 128 / WIDTH;

					        pixels[ p + 0 ] = noise( x, y, 123.4 );
						pixels[ p + 1 ] = 0;
						pixels[ p + 2 ] = 0;
						pixels[ p + 3 ] = 1;

						p += 4;
					}
				}

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(400, 400);

			}

			function setMouseCoords( x, y ) {

				mouseCoords.set( ( x / renderer.domElement.clientWidth ) * 2 - 1, - ( y / renderer.domElement.clientHeight ) * 2 + 1 );
				mouseMoved = true;

			}

			function onDocumentMouseMove( event ) {

				setMouseCoords( event.clientX, event.clientY );

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					setMouseCoords( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );


				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					setMouseCoords( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );


				}

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
			}

			function render() {

				waterMesh.rotation.z += 0.005
				waterMesh.rotation.y += 0.002
				waterMesh.rotation.x += 0.002
				arr = [-1, 1];
				// waterMesh.position.z += Math.random * arr[Math.floor(Math.random() * arr.length)];
				// Set uniforms: mouse interaction
				var uniforms = heightmapVariable.material.uniforms;
				if ( mouseMoved ) {

					this.raycaster.setFromCamera( mouseCoords, camera );

					var intersects = this.raycaster.intersectObject( meshRay );

					if ( intersects.length > 0 ) {
					    var point = intersects[ 0 ].point;
					    uniforms.mousePos.value.set( point.x, point.z );

					}
					else {
					    uniforms.mousePos.value.set( 10000, 10000 );
					}

					mouseMoved = false;
				}
				else {
					uniforms.mousePos.value.set( 10000, 10000 );
				}

				// Do the gpu computation
				gpuCompute.compute();

				// Get compute output in custom uniform
				waterUniforms.heightmap.value = gpuCompute.getCurrentRenderTarget( heightmapVariable ).texture;

				// Render
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
