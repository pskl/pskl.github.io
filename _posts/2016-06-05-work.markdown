---
layout: post
title:  "Work"
date:   2016-06-05 15:15:26
published: true
categories: jekyll update
---

In this article I will try to detail a bit the choices I made in terms of work tools and procedures. Those apply to either a pro activity or hobby. Every opinion expressed here is just an opinion, don't go on a crusade for that. Any valuable input is greatly appreciated. This what works for me, find what works for you.

## Text editor

The battle for the best editor is still raging and many of the contestants have some very strong arguments. Here is an overview of the editors I tried so far:

 - **[VIM](http://www.vim.org/)**

>the oldschool choice for purists and minimalists. It offers the best typing experience one can ask for. This editor is ubiquitous, it's installed natively on most Linux/UNIX based servers/personal computers thus making it a really safe choice. It requires dedication over time and a willingness to lose productivity temporarily. Also it is the opposite of an [Omakase](https://en.wikipedia.org/wiki/Omakase) editor: it comes out barebones and one needs to furnish it with a shit-ton of plugins to do even the simple things. One could say its like the [npm](https://www.npmjs.com/) of text editors but that would be quite a stretch.

:white_check_mark: Nerd cred ++, powerfullest, everywhere, cool as fuck

:no_entry_sign: Balls hard to master, kinda weird, [RSI](https://en.wikipedia.org/wiki/Repetitive_strain_injury)

- **[Emacs](https://www.gnu.org/software/emacs/)**

>is a sibling of VIM. Has a lot of similar good sides but is not as ubiquitous as far as I know.

:no_entry_sign: Not ubiquitous

- **[Nano](https://www.nano-editor.org/)**

>is a noob-friendly barebones editor which comes with many UNIX systems.

:white_check_mark: Neat name

:no_entry_sign: Feature set very limited, cool factor ~ 0 %

- **[Sublime Text](https://www.sublimetext.com/)**

>used to be the gold standard of user-friendly text editors because it offers right out of the box a very good typing experience with helpful shortcuts and a clean UI.
Sublime Text is written in C++ which makes it pretty fast and reliable. Think of this editor as the father of Atom. The Sublime ecosystem is mature and has a lot of good plugins. It is not as customizable as Atom though.

:white_check_mark: Fast, simple, kinda noob friendly

:no_entry_sign: Not free

- **[Atom](https://atom.io/)**

>the latest contestant on the market and the brainchild of the infamous [Github](https://github.com). It took all the right elements of Sublime Text and improved some of those. It feels fresher, comes with a lot of good plugins right-out-the-box and is fully customizable. Keep in mind that Atom is a bit slow on older hardware and can choke like a bitch on large files.

:white_check_mark: Noob friendly, cool, slick, free

:no_entry_sign: ~~Sometimes~~ Most of the times slow

Whatever the editor you decide to go with learn how to use it because it has amazing features that will make your life simpler.

## Color scheme

I use solarized wich comes out of the box with atom and which is pretty eye candy. On that aspect it boils down to personal preferences but I find that the majority of developers find that dark themes are better for long term use of a computer screen. In addition to that I use [F.lux](https://justgetflux.com) a color adjusting software that changes the temperature of the display over the course of a day.

## Terminal

How good is the default Terminal.app from OSX?
Well pretty good but iTerm is definitely better on the following aspects :

+ ability to split panes as much as you want
+ text search within the Terminal

## Shell

The most ubiquitous shell is obviously Bash. It's everywhere and offers a lot of things right out of the box.
But the thing is that Bash is pretty outdated technology and is missing a lot of improvements compared to his cousins like zsh, fish, etc...

To me the best alternative to Bash right now is Zsh which stays close to Bash but brings a lot of improvements.

To further bring out the good sides and have a good out-of-the-box experience I highly suggest using [Oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh) which brings UI improvements and easy customization. (see [my .zshrc](https://github.com/pskl/dotfiles/blob/master/.zshrc)).

<img class='post-image' src="https://raw.githubusercontent.com/pskl/pskl.github.io/master/assets/screen-view.png">

This is what my screen looks like when I'm working. I like to have my console along my editor which I split because having two shells (or 24) is convenient.

## 'Lean' project management

I always try to go directly to the 'making' step and skip the 'blueprint' step. The blueprint step is most of the time useless. Now don't get me wrong: when > 2 persons are involved in a project then project management tools and blueprints become necessary and it can work great if done right. But for small personal projects just make the first iteration and then adjust your shot, really.

This is how 99,99% of side projects die in the wilderness:

* you're talking with a friend, drinking :coffee: or :beer:
* you have a great idea
* you get excited :tada:
* you start seeing in your mind how great it could become
* you start making sketches
* you start planning features
* you see the insane potential of this things
* you start thinking too big and too distant :telescope:
* you leave the coffeeshop the mind full of stars and extremely pumped (same for your buddy) :star:
* life goes on :walking:
* the thing you planned is too complicated even on first step
* you never do it or postpone so called 'project sessions'
* you don't see results hence the willingness to achieve it dies off
* your friend experiences the same feelings and gets bored
* 1 month passes
* project status: :skull:

Solution: think as small as possible first, don't overshoot, think short, make something out of it before it fades away.

## Linters

Writting code is tedious, software that monitors what you write and gives you hints is highly beneficial. For example in the Ruby ecosystem one good linter is [Rubocop](https://github.com/bbatsov/rubocop) which enforces a few style rules.

## Tests

Any change (even the smallest) to your codebase as the potential to wreck the whole thing. Having a test suite will save you a lot of time if you plan to make gradual improvements to the project. If it's a one shot don't even bother.


## Conclusion

Use `VIM` if you want to dedicate your life to file editing. Use whatever makes you comfortable if not. If you're a total noob: use Atom. Don't lose yourself in project planning which is just cruft in most cases. Get your hands dirty, do it. Don't think too much. Don't overthink. What matters is what's there and how much of it actually works.

<img class='post-image' src="http://pascal.cc/assets/gifs/cat_business.gif">
